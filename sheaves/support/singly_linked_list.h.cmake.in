
//
// Copyright (c) 2013 Limit Point Systems, Inc. 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

#ifndef SINGLY_LINKED_LIST_H
#define SINGLY_LINKED_LIST_H

#cmakedefine HAVE_FORWARD_LIST 1

// Include the appropriate header file.

#ifdef HAVE_FORWARD_LIST
#include <forward_list>
#else
#include <ext/slist>
#endif

namespace sheaf
{

///
/// Wrapper class for forward_list or slist depending on compiler.
/// The class replicates the minimum subset of the forward_list and
/// slist classes.  It also implements a push_front function that
/// takes a range.
///
/// @hack This wrapper is a temporary fix until gcc-4.2.2 is no longer
///       supported.
///
template <typename T, class A = allocator<T> > class singly_linked_list
{
public:

#ifdef HAVE_FORWARD_LIST
   typedef std::forward_list<T, A>::value_type value_type;
   typedef std::forward_list<T, A>::size_type size_type;
   typedef std::forward_list<T, A>::difference_type difference_type;
   typedef std::forward_list<T, A>::reference reference;
   typedef std::forward_list<T, A>::const_reference const_reference;
   typedef std::forward_list<T, A>::pointer pointer;
   typedef std::forward_list<T, A>::iterator iterator;
   typedef std::forward_list<T, A>::const_iterator const_iterator;
#else
   typedef __gnu_cxx::slist<T, A>::value_type value_type;
   typedef __gnu_cxx::slist<T, A>::size_type size_type;
   typedef __gnu_cxx::slist<T, A>::difference_type difference_type;
   typedef __gnu_cxx::slist<T, A>::reference reference;
   typedef __gnu_cxx::slist<T, A>::const_reference const_reference;
   typedef __gnu_cxx::slist<T, A>::pointer pointer;
   typedef __gnu_cxx::slist<T, A>::iterator iterator;
   typedef __gnu_cxx::slist<T, A>::const_iterator const_iterator;
#endif

   single_linked_list()
   {
   };

   single_linked_list(size_type xcount)
     : _list(xcount)
   {
   };

private:

#ifdef HAVE_FORWARD_LIST
  std::forward_list<T, A> _list;
#else
  __gnu_cxx::slist<T, A> _list;
#endif

}

#endif // SINGLY_LINKED_LIST_H
